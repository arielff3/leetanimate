{
  "common": {
    "settings": "Configurações",
    "theme": "Tema",
    "language": "Idioma",
    "light": "Claro",
    "dark": "Escuro",
    "system": "Sistema",
    "portuguese": "Português",
    "english": "Inglês"
  },
  "validation": {
    "arrayRequired": "Array não pode estar vazio",
    "arrayInvalidNumbers": "Array deve conter apenas números separados por vírgula",
    "arrayMinElements": "Array deve ter pelo menos 2 elementos",
    "targetRequired": "Target não pode estar vazio",
    "targetInvalid": "Target deve ser um número válido"
  },
  "home": {
    "title": "Algoritmos LeetCode Animados",
    "subtitle": "Visualize e aprenda algoritmos do LeetCode através de animações interativas educativas.",
    "categories": {
      "arrays": "Arrays"
    },
    "algorithms": {
      "twoSum": {
        "title": "Two Sum",
        "description": "Encontre dois números em um array que somem um valor alvo específico."
      },
      "threeSum": {
        "title": "Three Sum", 
        "description": "Encontre todos os triplets únicos no array que somem zero."
      },
      "removeDuplicates": {
        "title": "Remove Duplicates from Sorted Array",
        "description": "Remova os elementos duplicados de um array ordenado in-place."
      }
    },
    "difficulty": {
      "easy": "Fácil",
      "medium": "Médio",
      "hard": "Difícil"
    }
  },
  "twoSum": {
    "title": "Two Sum",
    "titleWithMethod": "Two Sum - {method}",
    "backButton": "Voltar",
    "category": "Arrays • Fácil",
    "methodSelector": "Método de Solução",
    "selectMethod": "Selecione o método",
    "methods": {
      "hashmap": "Hash Map",
      "twopointers": "Two Pointers"
    },
    "tags": {
      "hashMap": "#hash-map",
      "onTime": "#O(n)-tempo",
      "onSpace": "#O(n)-espaço",
      "twoPointers": "#two-pointers",
      "nlogTime": "#O(nlogn)-tempo",
      "o1Space": "#O(1)-espaço"
    },
    "tabs": {
      "description": "Descrição",
      "code": "Código",
      "solution": "Solução"
    },
    "description": {
      "title": "Enunciado do Problema",
      "problem": "Dado um array de inteiros nums e um inteiro target, retorne os índices dos dois números que somam o valor target.",
      "assumption": "Você pode assumir que cada entrada terá exatamente uma solução, e você não pode usar o mesmo elemento duas vezes.",
      "order": "Você pode retornar a resposta em qualquer ordem.",
      "examples": "Exemplos",
      "example1": "Exemplo 1",
      "example2": "Exemplo 2",
      "example3": "Exemplo 3",
      "input": "Entrada",
      "output": "Saída",
      "explanation": "Explicação",
      "example1Explanation": "Porque nums[0] + nums[1] == 9, retornamos [0, 1].",
      "constraints": "Restrições",
      "constraint1": "2 ≤ nums.length ≤ 10⁴",
      "constraint2": "-10⁹ ≤ nums[i] ≤ 10⁹",
      "constraint3": "-10⁹ ≤ target ≤ 10⁹",
      "constraint4": "Apenas uma resposta válida existe.",
      "followUp": "Pergunta de Acompanhamento",
      "followUpText": "Você consegue criar um algoritmo que seja mais eficiente que O(n²) em complexidade temporal?"
    },
    "code": {
      "implementations": "Implementações - {method}",
      "javascript": "JavaScript",
      "python": "Python",
      "copy": "Copiar",
      "solution": "Solução {method}",
      "algorithmExplanation": "Explicação do Algoritmo - {method}",
      "approach": "Abordagem",
      "complexity": "Complexidade",
      "time": "Tempo",
      "space": "Espaço",
      "steps": "Passos do Algoritmo"
    },
    "preview": {
      "title": "Prévia da Animação - {method}",
      "array": "nums = {nums}, target = {target}",
      "play": "Executar Prévia",
      "pause": "Pausar",
      "restart": "Reiniciar",
      "status": {
        "clickToStart": "Clique para iniciar ({method})",
        "hashMapStep1": "Verificando nums[0] = 2, procurando complemento 7",
        "hashMapStep2": "Verificando nums[1] = 7, encontrado complemento!",
        "twoPointersStep1": "L=0, R=3: 2+15=17 > 9, mover R",
        "twoPointersStep2": "L=0, R=2: 2+11=13 > 9, mover R",
        "twoPointersStep3": "L=0, R=1: 2+7=9 = target!",
        "solutionFound": "✓ Solução encontrada: [{indices}]"
      }
    },
    "solution": {
      "title": "Visualização do Algoritmo",
      "execute": "Executar",
      "pause": "Pausar",
      "restart": "Reiniciar",
      "nextStep": "Próximo Passo",
      "reset": "Resetar",
      "speed": "Velocidade",
      "customize": "Personalizar",
      "speedOptions": {
        "slow": "Lento",
        "normal": "Normal",
        "fast": "Rápido"
      },
      "customization": {
        "title": "Personalizar Exemplo",
        "arrayLabel": "Array (separado por vírgulas)",
        "targetLabel": "Target",
        "apply": "Aplicar"
      },
      "visualization": "Visualização",
      "array": "Array",
      "target": "target = {target}",
      "currentStatus": "Status Atual",
      "algorithmSelected": "Algoritmo selecionado: {method}",
      "solutionFound": "Solução encontrada nos índices [{indices}]!",
      "predefinedExamples": "Exemplos Pré-definidos",
      "example": "Exemplo",
      "checking": "Verificando",
      "lookingForComplement": "procurando complemento",
      "noSolutionFound": "Nenhuma solução encontrada para este array e target.",
      "leftPointer": "L",
      "rightPointer": "R",
      "performanceMetrics": "Métricas de Performance",
      "operations": "Operações",
      "comparisons": "Comparações",
      "timeComplexity": "Complexidade Tempo",
      "spaceComplexity": "Complexidade Espaço",
      "hashMapVisualization": "Visualização do Hash Map",
      "currentSize": "Tamanho atual",
      "elements": "elemento(s)",
      "stepHistory": "Histórico de Passos",
      "waitingToStart": "Aguardando início",
      "verifying": "Verificando",
      "complement": "Complemento",
      "pointers": "Ponteiros",
      "sum": "Soma",
      "algorithmFinished": "Algoritmo finalizado",
      "noSolutionAfterCheck": "Nenhuma solução encontrada após verificar todos os elementos",
      "finished": "Finalizado",
      "algorithmCompleted": "Algoritmo concluído sem encontrar solução",
      "solutionFoundDetailed": "Solução encontrada!",
      "calculating": "Calculando complemento",
      "complementFound": "Complemento {complement} encontrado no índice {index}!",
      "complementNotFound": "Complemento não encontrado. Adicionando {num} → {index} ao hash map",
      "hashMapContains": "Hash map agora contém {size} elemento(s)",
      "processing": "Processando elemento {current}/{total}",
      "initializingTwoPointers": "Inicializando Two Pointers",
      "arraySorted": "Array ordenado: [{array}]. Ponteiros: L=0, R={right}",
      "arrayOrderedPointers": "Array ordenado e ponteiros inicializados",
      "sortingComplexity": "Complexidade da ordenação: O(n log n) = O({n} log {n})",
      "comparing": "Comparando L={left}, R={right}",
      "sumEqualsTarget": "Soma igual ao target! Índices originais: [{indices}]",
      "sumLessThanTarget": "Soma < target, mas ponteiros se encontraram. Nenhuma solução encontrada.",
      "sumGreaterThanTarget": "Soma > target, mas ponteiros se encontraram. Nenhuma solução encontrada.",
      "movingLeftPointer": "Soma < target, movendo ponteiro esquerdo: L={oldLeft} → L={newLeft}",
      "movingRightPointer": "Soma > target, movendo ponteiro direito: R={oldRight} → R={newRight}",
      "movingLeftSmallSum": "Movendo ponteiro esquerdo (soma muito pequena)",
      "movingRightLargeSum": "Movendo ponteiro direito (soma muito grande)",
      "nextComparison": "Próxima comparação: nums[{left}] + nums[{right}]",
      "solutionDetailed": "Solução: nums[{index1}] + nums[{index2}] = {val1} + {val2} = {target}",
      "indexArrow": "→ índice {index}",
      "nextComparisonDetailed": "Próxima comparação: nums[{left}] + nums[{right}]"
    },
    "algorithmExplanations": {
      "hashmap": {
        "title": "Hash Map (Uma Passada)",
        "description": "Esta solução utiliza um hash map para armazenar os números já visitados e seus índices. Para cada elemento, calculamos o complemento (target - elemento atual) e verificamos se ele já existe no hash map.",
        "complexity": {
          "time": "O(n) - onde n é o número de elementos no array",
          "space": "O(n) - no pior caso, armazenamos todos os elementos no hash map"
        },
        "steps": [
          "Criar um hash map vazio",
          "Para cada elemento no array:",
          "• Calcular o complemento (target - elemento atual)",
          "• Se o complemento existir no hash map, retornar os índices",
          "• Caso contrário, adicionar o elemento atual e seu índice ao hash map",
          "Continuar até encontrar a solução"
        ]
      },
      "twopointers": {
        "title": "Two Pointers",
        "description": "Esta solução primeiro cria um array com os valores e seus índices originais, depois ordena por valor. Usa dois ponteiros: um no início (left) e outro no fim (right). Move os ponteiros baseado na soma atual comparada com o target.",
        "complexity": {
          "time": "O(n log n) - devido à ordenação do array",
          "space": "O(n) - para armazenar o array com índices originais"
        },
        "steps": [
          "Criar array com valores e índices originais",
          "Ordenar o array por valor",
          "Inicializar ponteiros left=0 e right=length-1",
          "Enquanto left < right:",
          "• Se soma == target: retornar índices originais",
          "• Se soma < target: mover left para direita",
          "• Se soma > target: mover right para esquerda"
        ]
      }
    }
  },
  "removeDuplicates": {
    "title": "Remove Duplicates from Sorted Array",
    "titleWithMethod": "Remove Duplicates from Sorted Array - {method}",
    "backButton": "Voltar",
    "category": "Arrays • Fácil",
    "methodSelector": "Método de Solução",
    "selectMethod": "Selecione o método",
    "methods": {
      "twopointers": "Two Pointers"
    },
    "tags": {
      "twoPointers": "#two-pointers",
      "onTime": "#O(n)-tempo",
      "o1Space": "#O(1)-espaço",
      "inPlace": "#in-place"
    },
    "tabs": {
      "description": "Descrição",
      "code": "Código",
      "solution": "Solução"
    },
    "description": {
      "title": "Enunciado do Problema",
      "problem": "Dado um array de inteiros nums ordenado em ordem não-decrescente, remova os duplicados in-place de modo que cada elemento único apareça apenas uma vez. A ordem relativa dos elementos deve ser mantida.",
      "return": "Retorne k após colocar os primeiros k elementos únicos nas primeiras k posições do array nums. Não importa o que você deixar além das primeiras k posições.",
      "clarification": "Não aloque espaço extra para outro array. Você deve fazer isso modificando o array de entrada in-place com memória extra O(1).",
      "examples": "Exemplos",
      "example1": "Exemplo 1",
      "example2": "Exemplo 2",
      "input": "Entrada",
      "output": "Saída",
      "explanation": "Explicação",
      "example1Explanation": "Sua função deve retornar k = 2, com os dois primeiros elementos de nums sendo 1 e 2. Não importa o que você deixar além do k retornado.",
      "example2Explanation": "Sua função deve retornar k = 5, com os cinco primeiros elementos de nums sendo 0, 1, 2, 3 e 4. Não importa o que você deixar além do k retornado.",
      "constraints": "Restrições",
      "constraint1": "1 ≤ nums.length ≤ 3 * 10⁴",
      "constraint2": "-100 ≤ nums[i] ≤ 100",
      "constraint3": "nums está ordenado em ordem não-decrescente"
    },
    "code": {
      "implementations": "Implementações - {method}",
      "javascript": "JavaScript",
      "python": "Python",
      "copy": "Copiar",
      "solution": "Solução {method}",
      "algorithmExplanation": "Explicação do Algoritmo - {method}",
      "approach": "Abordagem",
      "complexity": "Complexidade",
      "time": "Tempo",
      "space": "Espaço",
      "steps": "Passos do Algoritmo"
    },
    "preview": {
      "title": "Prévia da Animação - {method}",
      "array": "nums = [{nums}]",
      "play": "Executar Prévia",
      "pause": "Pausar",
      "restart": "Reiniciar",
      "status": {
        "clickToStart": "Clique para iniciar ({method})",
        "twoPointersStep1": "unique=0, read=1: comparando nums[0]=1 com nums[1]=1",
        "twoPointersStep2": "unique=0, read=2: comparando nums[0]=1 com nums[2]=2, escrevendo",
        "twoPointersFinished": "✓ Array processado, comprimento único: {length}"
      }
    },
    "solution": {
      "title": "Visualização do Algoritmo",
      "execute": "Executar",
      "pause": "Pausar",
      "restart": "Reiniciar",
      "nextStep": "Próximo Passo",
      "reset": "Resetar",
      "speed": "Velocidade",
      "customize": "Personalizar",
      "speedOptions": {
        "slow": "Lento",
        "normal": "Normal",
        "fast": "Rápido"
      },
      "customization": {
        "title": "Personalizar Exemplo",
        "arrayLabel": "Array (separado por vírgulas)",
        "apply": "Aplicar"
      },
      "visualization": "Visualização",
      "array": "Array",
      "currentStatus": "Status Atual",
      "algorithmSelected": "Algoritmo selecionado: {method}",
      "predefinedExamples": "Exemplos Pré-definidos",
      "example": "Exemplo",
      "performanceMetrics": "Métricas de Performance",
      "operations": "Operações",
      "comparisons": "Comparações",
      "writes": "Escritas",
      "timeComplexity": "Complexidade Tempo",
      "spaceComplexity": "Complexidade Espaço",
      "uniquePointer": "unique",
      "readPointer": "read",
      "finished": "Finalizado",
      "algorithmCompleted": "Algoritmo concluído",
      "finalResult": "Resultado final: {length} elementos únicos",
      "processingElement": "Processando elemento {current}/{total}",
      "comparing": "Comparando",
      "duplicate": "Duplicado encontrado",
      "unique": "Elemento único encontrado",
      "writing": "Escrevendo elemento único",
      "skipping": "Pulando duplicado",
      "initializingPointers": "Inicializando ponteiros",
      "pointersReady": "Ponteiros unique=0, read=1 prontos",
      "checkingElement": "Verificando nums[{read}] = {value}",
      "duplicateFound": "nums[{unique}] = nums[{read}] = {value}, pulando",
      "uniqueFound": "nums[{unique}] ≠ nums[{read}], movendo unique para {newUnique}",
      "writingUnique": "Escrevendo nums[{read}] = {value} em nums[{unique}]",
      "algorithmFinished": "Algoritmo finalizado",
      "finalLength": "Comprimento final do array único: {length}",
      "movingPointers": "Movendo ponteiros: unique={unique}, read={read}",
            "currentComparison": "Comparação atual: nums[{unique}] vs nums[{read}]",
      "exampleLabel": "Exemplo",
      "pointers": "Ponteiros",
      "waitingToStart": "Aguardando início",
      "stepHistory": "Histórico de Passos"
    },
    "algorithmExplanations": {
      "twopointers": {
        "title": "Two Pointers (Otimizado)",
        "description": "Esta solução utiliza dois ponteiros: 'unique' para a posição onde escrever o próximo elemento único, e 'read' para percorrer o array. Como o array está ordenado, elementos duplicados são consecutivos.",
        "complexity": {
          "time": "O(n) - onde n é o número de elementos no array",
          "space": "O(1) - apenas espaço constante extra é usado"
        },
        "steps": [
          "Inicializar ponteiro unique = 0 e read = 1",
          "Enquanto read < array.length:",
          "• Se nums[unique] != nums[read]:",
          "  - Incrementar unique",
          "  - Copiar nums[read] para nums[unique]",
          "• Incrementar read",
          "Retornar unique + 1 (quantidade de elementos únicos)"
        ]
      }
    }
  }
} 